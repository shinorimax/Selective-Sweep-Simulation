---
title: "Hotellings_t_test"
author: "Shinnosuke Yagi"
date: "2025-11-04"
output: html_document
---

## Overview

1. Take weighted average of all F-matrices / FW-matrices (weighted) on a chromosome
2. Conduct Hotelling's T^2 test

## Import Libraries

```{r, message=FALSE}
library(ape)
library(spam)
library(devtools)
library(INLA)
library(pROC)
library(ggplot2)
library(dplyr)
library(purrr)
library(readr)
library(stringr)
library(fmatrix)
library(ICSNP)
```

```{r}
# install_github("JuliaPalacios/phylodyn")
library(phylodyn)
source("hotelling.R")
```

## Load genome-wide weighted-average trees (n=10)

```{r}
F_weighted_neutrals <- readRDS("data/F_weighted_average_neutrals_n10.rds")
F_weighted_selectives_s0.01_f0.75 <- readRDS("data/F_weighted_average_selectives_n10_s0.01_f0.75.rds")

# --- Helper function for L1 distance (unweighted) ----
dist_d1 <- function(F1, F2) {
  sum(abs(F1 - F2))
}

# --- 1. Split the neutral list: use the second half for testing ---------------
n_total <- length(F_weighted_neutrals)
half_idx <- floor(n_total / 2) + 1
# F_weighted_list_neutral_test <- F_weighted_neutrals[half_idx:n_total]
F_weighted_list_neutral_test <- F_weighted_neutrals

# --- 2. Load or reference the selective set ----------------------------------
F_weighted_list_selective <- F_weighted_selectives_s0.01_f0.75
```


```{r}
# vectorize F-matrices -> rows = trees, cols = features
vecF <- function(F) as.numeric(F)
X_neu <- do.call(rbind, lapply(F_weighted_list_neutral_test, vecF))
Y_sel <- do.call(rbind, lapply(F_weighted_list_selective, vecF))

# quick check for feasibility of plain Hotelling
p <- ncol(X_neu); nxy <- nrow(X_neu) + nrow(Y_sel)
cat("p =", p, " | n_x + n_y - 2 =", nxy - 2, "\n")

myHotelling(X_neu, Y_sel)  # TRUE if p<0.05, FALSE if not, NA if singular/error
```

## Load F-matrices

```{r}
Fs_nested_neutrals <- readRDS("data/Fs_nested_neutrals.rds")
Fs_nested_selectives <- readRDS("data/Fs_nested_selectives_s0.01_f0.75.rds")
```

```{r}
# Keep only the informative half of F (lower triangle incl. diag)
lower_vec <- function(F) as.numeric(F[lower.tri(F, diag = TRUE)])

stack_from_nested <- function(nested_list) {
  do.call(rbind, lapply(nested_list, function(sublist) {
    if (length(sublist) == 0) return(NULL)
    do.call(rbind, lapply(sublist, lower_vec))
  }))
}

# Build X (neutrals) from nested:
X_neu <- stack_from_nested(Fs_nested_neutrals)

# Build Y (selectives):
# If you ALSO have nested selectives:
Y_sel <- stack_from_nested(Fs_nested_selectives)

# If your selectives are a simple list:
# vecF_lower <- function(F) as.numeric(F[lower.tri(F, diag = TRUE)])
# Y_sel <- do.call(rbind, lapply(F_weighted_list_selective, vecF_lower))

# Feasibility check
p <- ncol(X_neu); nxy <- nrow(X_neu) + nrow(Y_sel)
cat("p =", p, " | n_x + n_y - 2 =", nxy - 2, "\n")
```

```{r}
# your function already prunes truly constant & equal-mean columns
myHotelling(X_neu, Y_sel)
```

### Subsample

```{r}
## --- Helpers (unchanged) ----------------------------------------------------
lower_vec <- function(F) as.numeric(F[lower.tri(F, diag = TRUE)])

dedup_by_F <- function(sublist) {
  if (length(sublist) <= 1) return(sublist)
  keys <- vapply(sublist, function(F) paste(lower_vec(F), collapse = ","), "")
  sublist[!duplicated(keys)]
}

thin_sublist <- function(sublist, k = 10, dedup = TRUE) {
  if (dedup) sublist <- dedup_by_F(sublist)
  L <- length(sublist)
  if (L == 0) return(list())
  if (L <= k) return(sublist)
  idx <- unique(round(seq(1, L, length.out = k)))
  sublist[idx]
}

## --- Thinning with a progress bar ------------------------------------------
thin_nested_pb <- function(nested, k = 10, dedup = TRUE, label = "Thinning") {
  n <- length(nested)
  out <- vector("list", n)
  pb <- txtProgressBar(min = 0, max = n, style = 3)
  on.exit(close(pb), add = TRUE)
  cat(label, "\n")
  for (i in seq_len(n)) {
    out[[i]] <- thin_sublist(nested[[i]], k = k, dedup = dedup)
    setTxtProgressBar(pb, i)
  }
  out
}

## --- Flatten nested -> matrix with a progress bar ---------------------------
flatten_to_matrix_pb <- function(nested, label = "Flattening") {
  n <- length(nested)
  mats <- vector("list", n)
  pb <- txtProgressBar(min = 0, max = n, style = 3)
  on.exit(close(pb), add = TRUE)
  cat(label, "\n")
  for (i in seq_len(n)) {
    sub <- nested[[i]]
    if (length(sub)) {
      mats[[i]] <- do.call(rbind, lapply(sub, lower_vec))
    } else {
      mats[[i]] <- NULL
    }
    setTxtProgressBar(pb, i)
  }
  do.call(rbind, mats)
}

## --- (Optional) progress bar for a simple (non-nested) list -----------------
flatten_simple_list_pb <- function(F_list, label = "Flattening (simple list)") {
  n <- length(F_list)
  pb <- txtProgressBar(min = 0, max = n, style = 3)
  on.exit(close(pb), add = TRUE)
  cat(label, "\n")
  out <- vector("list", n)
  for (i in seq_len(n)) {
    out[[i]] <- lower_vec(F_list[[i]])
    setTxtProgressBar(pb, i)
  }
  do.call(rbind, out)
}

## --- Example usage ----------------------------------------------------------
# Neutrals: thin to 10 trees per chromosome, then flatten
neu_thin <- thin_nested_pb(Fs_nested_neutrals, k = 15, dedup = TRUE, label = "Thinning neutrals")
X_neu    <- flatten_to_matrix_pb(neu_thin, label = "Flattening neutrals")

# Selectives: if nested
sel_thin <- thin_nested_pb(Fs_nested_selectives, k = 15, dedup = TRUE, label = "Thinning selectives")
Y_sel    <- flatten_to_matrix_pb(sel_thin, label = "Flattening selectives")

# ...or if selectives are a simple list of F-matrices
# Y_sel <- flatten_simple_list_pb(F_weighted_list_selective, label = "Flattening selectives (simple list)")

# Quick feasibility check and run your test
p   <- ncol(X_neu); nxy <- nrow(X_neu) + nrow(Y_sel)
cat("p =", p, "| n_x + n_y - 2 =", nxy - 2, "\n")
myHotelling(X_neu, Y_sel)   # TRUE if p < 0.05, FALSE otherwise, NA if singular
```

```{r}
# --- Step A: drop constant / near-constant columns (pooled) ------------------
prune_constants <- function(X, Y, tol_sd = 1e-12) {
  Z <- rbind(X, Y)
  keep <- apply(Z, 2, sd) > tol_sd
  list(
    X = X[, keep, drop = FALSE],
    Y = Y[, keep, drop = FALSE],
    keep = keep
  )
}

pc <- prune_constants(X_neu, Y_sel, tol_sd = 1e-12)
X1 <- pc$X; Y1 <- pc$Y

# --- Step B: drop exact linear dependencies using QR on pooled, centered -----
# (This picks a maximal set of independent columns)
Z1 <- rbind(scale(X1, center = TRUE, scale = FALSE),
            scale(Y1, center = TRUE, scale = FALSE))
qrZ <- qr(Z1)                     # rank-revealing QR
rnk  <- qrZ$rank
keep_idx <- sort(qrZ$pivot[1:rnk])

X2 <- X1[, keep_idx, drop = FALSE]
Y2 <- Y1[, keep_idx, drop = FALSE]

cat("After pruning: p =", ncol(X2),
    "| n_x + n_y - 2 =", nrow(X2) + nrow(Y2) - 2, "\n")

# --- Step C: run classical Hotelling (should no longer be singular) ----------
pval <- ICSNP::HotellingsT2(X2, Y2)$p.value
cat(sprintf("Hotelling's T^2 p-value: %.3g\n", pval))
```

```{r}
nullx <- gen_x(0, m=50, n= 10)
altx <- gen_x(1, m=50, n= 10)
```

```{r}
myHotelling(altx, nullx)
```
