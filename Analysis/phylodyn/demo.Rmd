---
title: "demo"
author: "Shinnosuke Yagi"
date: "2025-10-23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE}
library(ape)
library(spam)
library(devtools)
library(INLA)
library(pROC)
library(ggplot2)
library(dplyr)
library(purrr)
library(readr)
library(stringr)
library(pROC)
```

```{r}
install_github("JuliaPalacios/phylodyn")
library(phylodyn)
```

## Load Simulated Trees

```{r}
# Read a .tree file (Newick format)
tree1 <- read.tree("/Users/yagishinnosuke/Documents/2025-2026 Stanford/Palacios Lab/demo_trees/neutral_rep_001.tree")

tree2 <- read.tree("/Users/yagishinnosuke/Documents/2025-2026 Stanford/Palacios Lab/demo_trees/sweep_rep_001.tree")

# Check one tree
plot(tree1[[10]], type = "phylogram")
plot(tree2[[10]], type = "phylogram")

dist <- dist_pairwise(tree1[[1]], tree2[[1]], dist.method='l1', weighted=TRUE)
```

```{r}
# -------- helper to read "[left,right]\t<newick>" lines and get tree at a position --------
get_tree_at_pos <- function(path, pos, include_index = FALSE) {
  lines <- readLines(path)
  # split "[left,right]\t<newick>"
  parts <- strsplit(lines, "\t", fixed = TRUE)
  # parse intervals
  ivals <- do.call(rbind, lapply(parts, function(x) {
    nums <- gsub("\\[|\\]", "", x[[1]])
    as.numeric(strsplit(nums, ",", fixed = TRUE)[[1]])
  }))
  left <- ivals[, 1]
  right <- ivals[, 2]

  # find the tree interval covering 'pos' (left-closed, right-open)
  idx <- which(left <= pos & pos < right)
  if (length(idx) == 0) stop("No tree interval covers the requested position.")
  if (length(idx) > 1) warning("Multiple intervals matched; taking the first.")
  idx <- idx[1]

  # read that tree from its Newick text
  newick_txt <- parts[[idx]][[2]]
  tr <- read.tree(text = newick_txt)

  if (include_index) {
    attr(tr, "tree_index") <- idx
    attr(tr, "interval") <- c(left[idx], right[idx])
  }
  tr
}

# -------- inputs --------
L <- 100000
midpos <- L / 2

file_neutral <- "/Users/yagishinnosuke/Documents/2025-2026 Stanford/Palacios Lab/demo_trees/neutral_rep_001.tree"
file_sweep   <- "/Users/yagishinnosuke/Documents/2025-2026 Stanford/Palacios Lab/demo_trees/sweep_rep_001.tree"

# -------- grab the mid-point trees --------
tree1_mid <- get_tree_at_pos(file_neutral, pos = midpos, include_index = TRUE)
tree2_mid <- get_tree_at_pos(file_sweep,   pos = midpos, include_index = TRUE)

# (optional) inspect which line/interval you got
attributes(tree1_mid)$tree_index    # line number (1-based) in the file
attributes(tree1_mid)$interval      # c(left, right)
attributes(tree2_mid)$tree_index
attributes(tree2_mid)$interval

# -------- plot --------
plot(tree1_mid, type = "phylogram", main = sprintf("Neutral @ %.0f", midpos))
plot(tree2_mid, type = "phylogram", main = sprintf("Sweep @ %.0f", midpos))
```

## Load Simulated trees at L/2

```{r}
# --- Inputs ---
L <- 100000
midpos <- L/2
base_dir <- "/Users/yagishinnosuke/Documents/2025-2026 Stanford/Palacios Lab/demo_trees"

# Helper: read a file with lines "[left,right]\t<newick>" and return tree covering 'pos'
get_tree_at_pos <- function(path, pos) {
  lines <- readLines(path)
  parts <- strsplit(lines, "\t", fixed = TRUE)
  # extract [left,right]
  ivals <- do.call(rbind, lapply(parts, function(x) {
    nums <- gsub("\\[|\\]", "", x[[1]])
    as.numeric(strsplit(nums, ",", fixed = TRUE)[[1]])
  }))
  left <- ivals[, 1]
  right <- ivals[, 2]
  idx <- which(left <= pos & pos < right)
  if (length(idx) == 0) stop(sprintf("No interval covers pos=%.0f in %s", pos, path))
  idx <- idx[1]
  read.tree(text = parts[[idx]][[2]])
}

# List the 50 neutral and 50 sweep files
neutral_files <- sprintf(file.path(base_dir, "neutral_rep_%03d.tree"), 1:50)
sweep_files   <- sprintf(file.path(base_dir, "sweep_rep_%03d.tree"),   1:50)

stopifnot(all(file.exists(neutral_files)), all(file.exists(sweep_files)))

# Load mid-point trees
cat("Loading mid-point trees...\n")
neutral_mid <- lapply(neutral_files, get_tree_at_pos, pos = midpos)
sweep_mid   <- lapply(sweep_files,   get_tree_at_pos, pos = midpos)
cat("✓ Loaded all trees (50 neutral + 50 sweep)\n\n")
```

## Compute pairwise distances

```{r}
# --- Helper to compute pairwise distances with progress ---
pairwise_distances <- function(treelist, label = "Scenario", verbose = TRUE) {
  idx <- utils::combn(length(treelist), 2)
  n_pairs <- ncol(idx)
  v <- numeric(n_pairs)
  
  cat(sprintf("[%s] Computing %d pairwise distances...\n", label, n_pairs))
  last_percent <- 0
  
  for (k in seq_len(n_pairs)) {
    i <- idx[1, k]; j <- idx[2, k]
    v[k] <- dist_pairwise(treelist[[i]], treelist[[j]],
                          dist.method = "l1", weighted = TRUE)
    
    # progress indicator
    if (verbose) {
      pct <- round(100 * k / n_pairs)
      if (pct %% 5 == 0 && pct != last_percent) {
        cat(sprintf("[%s] %3d%% done (%d/%d)\n", label, pct, k, n_pairs))
        last_percent <- pct
      }
    }
  }
  cat(sprintf("[%s] ✓ Finished computing distances.\n\n", label))
  return(v)
}

# Compute distances
dist_neutral <- pairwise_distances(neutral_mid, label = "Neutral")
dist_sweep   <- pairwise_distances(sweep_mid,   label = "Sweep")
```

## Pairwise distance distribution

```{r}
# Combine and plot
df <- rbind(
  data.frame(scenario = "Neutral", distance = dist_neutral),
  data.frame(scenario = "Sweep",   distance = dist_sweep)
)

ggplot(df, aes(x = distance, fill = scenario)) +
  geom_density(alpha = 0.35, adjust = 1.0) +
  labs(
    title = sprintf("Pairwise L1 (weighted) distances among mid-point trees (L/2)"),
    x = "Pairwise tree distance (L1, weighted)",
    y = "Density"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "top")
```

## ROC_AUC Curve

```{r}
# 1) Prepare labels + scores
scores <- c(dist_neutral, dist_sweep)
labels <- factor(
  c(rep("Neutral", length(dist_neutral)), rep("Sweep", length(dist_sweep))),
  levels = c("Neutral", "Sweep")  # ensure "Sweep" is the positive class
)

# 2) ROC (direction picked automatically so higher/lower scores for sweeps both work)
roc_obj <- roc(response = labels, predictor = scores, levels = c("Neutral", "Sweep"), direction = "auto")

# 3) AUC
auc_val <- auc(roc_obj)
cat(sprintf("AUC = %.4f\n", as.numeric(auc_val)))

# 4) Best threshold (Youden's J) and its sensitivity/specificity
best <- coords(roc_obj, "best", best.method = "youden",
               ret = c("threshold", "sensitivity", "specificity", "tp", "fp", "tn", "fn"))
# print(best)

# 5) Plot ROC with AUC label
p_roc <- ggroc(roc_obj, legacy.axes = TRUE) +
  geom_abline(linetype = "dashed", color = "grey50") +
  labs(
    title = "ROC curve: classifying Sweep vs Neutral from pairwise tree distances",
    subtitle = sprintf("AUC = %.3f | Best threshold = %.4g (Sens=%.2f, Spec=%.2f)",
                       as.numeric(auc_val), best["threshold"], best["sensitivity"], best["specificity"]),
    x = "False Positive Rate (1 - Specificity)",
    y = "True Positive Rate (Sensitivity)"
  ) +
  theme_minimal(base_size = 13)
print(p_roc)

# # 6) (Optional) Inspect thresholds as a data.frame for custom plotting or picking your own cutoff
# roc_df <- data.frame(
#   threshold   = roc_obj$thresholds,
#   tpr         = roc_obj$sensitivities,
#   fpr         = 1 - roc_obj$specificities
# )
# head(roc_df)
```
