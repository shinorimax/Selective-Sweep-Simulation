---
title: "phylodyn analysis of msprime simulations"
output: html_notebook
---

input: text file of newick format outputs form msprime model simulations
engineering and the different types of ways...


```{r}
library (ape)
library (spam)
library (usethis)
library (devtools)
library (INLA)
library (phytools)
library(devtools)
library(phylodyn)
library(knitr)
library (ggplot2)
library(stringr)
```

parse data from input file
```{r}
file_path <- "/Users/yagishinnosuke/Documents/2024-2025 Stanford/Research/Selective-Sweep-Simulation/all_scenarios.txt"
```

```{r}
split_content <- function(lines) {
  combined <- paste(lines, collapse = "\n")
  paragraphs <- unlist(strsplit(combined, "\n\n"))
  return(paragraphs)
}

extract_and_remove_newick_trees <- function(strings_list) {
  num_scenarios = 0
  num_simulations = 0
  pattern <- "NEW"
  extracted_trees <- list()
  cleaned_strings <- list()
  
  for (string in strings_list) {
    matches <- str_extract_all(string, pattern)[[1]]
    
    if (length(matches) > 0) {
      extracted_trees <- c(extracted_trees, matches)
      num_scenarios = num_scenarios + 1
    } else {
      cleaned_strings <- c(cleaned_strings, string)
      num_simulations = num_simulations + 1
    }
  }
  cleaned_strings <- Filter(function(p) nchar(trimws(p)) > 0, cleaned_strings)
  return(list (cleaned_strings = cleaned_strings, num_simulations = num_simulations / 3))
}


content <- readLines(file_path, warn = FALSE)
paragraphs <- split_content(content)
result <- extract_and_remove_newick_trees(paragraphs)
num_simulations = result$num_simulations
clean <- result$cleaned_strings
```

lists a and t are lists of lists of tree in each scenario
each list in a, t are the list of a different selection coeffieienct's trees
```{r}
#create lists based on how many trees extracted from each scenario
a <- list (list(), list(), list())
t <- list (list(), list (), list()) #each list is a different scenario

by = length (clean) / 3      #need to add num_scenarios here

for (i in seq(1, length (a))){
  if (i > 1) {
    start = by * (i-1) + 1
    end = by*i
  } else {
    start = 1 #indices 1 - 1200
    end = by
  }
  k = 1
  
  for (j in seq (start, end)){
    temp_file <- tempfile (fileext = ".txt")
    writeLines (clean [[j]], con = temp_file)
    tr = read.tree (file = temp_file)
    t[[i]][[k]] <- tr
    fmat <- gen_Fmat (tr, tol = 5)
    a[[i]][[k]] <- fmat
    k = k+1
    unlink(temp_file)
  }
}
```

sort, each list within a, t is a different selection coefficient
all lists have all trees s, under selection (indices 1 - 300 are first scenario, 301-600 are second scenario, 601- 900 are third scenario)
```{r}
# 4 different trees extracted, 3 scenarios
s <- c(list(), list(), list()) #tree under selection
n <- c(list(), list(), list()) #tree next to it
l <- c(list(), list(), list()) #last tree
r <- c(list(), list(), list()) #random tree

chosen_list <- t
num = 1

for (i in seq (1, length (chosen_list))){
  this <- chosen_list [[i]]
  for (j in seq (1, length (this) - 1, by = 4)){
    s [[num]] <- this [[j]] # s [[1]] represents the tree under selection, 1 - 300 is from the first scenario
    n [[num]]<- this [[j + 1]]
    l [[num]]<- this [[j + 2]]
    r [[num]]<- this [[j + 3]]
    num = num + 1
  }
}


```


We will plot histograms of time to the most recent common ancestor (TMRCA)
```{r}
s_tr_list <- s [1:300]
n_tr_list <- n [1:300]
l_tr_list <- l [1:300]
r_tr_list <- r [1:300]

par(mfrow=c(2,2))
total<-c(0)
all<-list(s_tr_list,n_tr_list,l_tr_list,r_tr_list)
for (i in 1:4){
Treelength<-rep(0,length(all[[i]]))
for (j in 1:length(all[[i]])){
  Treelength[j]<-sum(coalescent.intervals(all[[i]][[j]])$lineages*coalescent.intervals(all[[i]][[j]])$interval.length)
}
total<-c(total,Treelength)
}
total<-total[-1]
par(mfrow=c(2,2))
hist(total[1:300])
hist(total[301:600])
hist(total[601:900])
hist(total[901:1200])
```

find pairwise distances (d1)
```{r}
options <- c("l1", "l2", FALSE, TRUE)

create_dmat <- function (tree_list, type, wbool) {
  dmat <- matrix(0, nrow=length(tree_list), ncol=length(tree_list))
  for (i in 1:length(tree_list)) {
      for (j in 1:i) {
          dmat[i,j] <- dist_pairwise(tree_list[[i]], tree_list[[j]], dist.method=options[[type]], weighted=options [[wbool]])
      }
  }
  return (dmat)
}

s_1_d1 <- create_dmat (s[1:300], 1, 3)
t_1_d1 <- create_dmat (n[1:300], 1, 3)
l_1_d1 <- create_dmat (l[1:300], 1, 3)
scenario_one_mat <- rbind (s_1_d1, t_1_d1, l_1_d1)
```

creates a distance matrix for one scenario
```{r}
plot_dist_mat <- function (dmat) {
  dmat <- dmat
  tmp <- dmat[lower.tri(dmat)]
  dmat <- t(dmat)
  dmat[lower.tri(dmat)] <- tmp
  mds_result <- cmdscale(dmat)
  temp_df <- data.frame(
  X = mds_result[, 1],
  Y = mds_result[, 2],
  List = "positive")
  
  plot (dmat)
}

dmat <- scenario_one_mat
tmp <- dmat[lower.tri(dmat)]
dmat <- t(dmat)
dmat[lower.tri(dmat)] <- tmp
mds_result <- cmdscale(dmat)
```
find average distances
```{r}
options <- c("l1", "l2", FALSE, TRUE)

st.err <- function(x) {
    sd(x)/sqrt(length(x))}

find_avg_dist <- function (first_list, second_list, method, w){
  temp <- list ()
  for (i in 1:length (first_list)) {
    temp [[num_index]] <- dist_pairwise (first_list [[i]], second_list [[i]], dist.method = options [[method]], weighted = options [[w]])
  }
  print (mean (unlist (temp)))
}


#simulation one:
print ("select & next:")
find_avg_dist (s[1:300],n[1:300], 1,3)

print ("select & last:")
find_avg_dist (s[1:300], l[1:300], 1, 3 )

print ("two neutrals:")
find_avg_dist (l[1:300], r[1:300], 1, 3)
```


```{r}
#simulation one:
print ("select & next:")
find_avg_dist (s[1:300],n[1:300], 1,4)

print ("select & last:")
find_avg_dist (s[1:300], l[1:300], 1,4)

print ("two neutrals:")
find_avg_dist (l[1:300], r[1:300], 1, 4)
```


```{r}
#simulation one:
print ("select & next:")
find_avg_dist (s[301:600],n[301:600], 1,4)

print ("select & last:")
find_avg_dist (s[301:600], l[301:600], 1,4)

print ("two neutrals:")
find_avg_dist (l[301:600], r[301:600], 1, 4)

```